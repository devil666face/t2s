package dns

import (
	"fmt"
	"log"
	"path/filepath"
	"regexp"
	"tun2socksme/pkg/fs"

	"github.com/miekg/dns"
)

var re = regexp.MustCompile(`^([^:]+):(\d+)/(tcp|udp)$`)

var (
	resolvconf = `
# Generated by tun2socksme.
# Stop tun2socksme for return default config.
nameserver %s
`
	respath = filepath.Join("/", "etc", "resolv.conf")
)

type server struct {
	address string
	port    string
	proto   string
}

func parse(resolver string) (server, error) {
	matches := re.FindStringSubmatch(resolver)
	if len(matches) != 4 {
		return server{}, fmt.Errorf("failed to parse dns line: %s", resolver)
	}
	_proto := matches[3]
	if _proto != "udp" && _proto != "tcp" {
		return server{}, fmt.Errorf("fauled to parse proto it must be udp/tcp")
	}
	return server{
		address: matches[1],
		port:    matches[2],
		proto:   _proto,
	}, nil
}

func parseResolvers(resolvers []string) []server {
	var servers = []server{}
	for i, resolv := range resolvers {
		server, err := parse(resolv)
		if i == 0 && server.proto != "tcp" {
			log.Fatalln("first resolver must be with proto \"tcp\" not:", server.proto)
		}
		if err != nil {
			log.Println(err)
			continue
		}
		servers = append(servers, server)
	}
	return servers
}

type Dns struct {
	listen     string
	server     *dns.Server
	resolvers  []server
	resolvconf []byte
	render     bool
}

func (d *Dns) resolv(w dns.ResponseWriter, r *dns.Msg) {
	client := &dns.Client{}
	for _, resolver := range d.resolvers {
		client.Net = resolver.proto
		resp, _, err := client.Exchange(r, fmt.Sprintf("%s:%s", resolver.address, resolver.port))
		if err != nil {
			// log.Printf("resolver %s failed or returned no answer: %s", resolver.address, err)
			continue
		}
		if resp == nil || len(resp.Answer) == 0 {
			// log.Printf("resolver %s not found record", resolver.address)
			continue
		}

		if err := w.WriteMsg(resp); err != nil {
			// log.Printf("failed to write response: %v", err)
			dns.HandleFailed(w, r)
			return
		}
		return
	}
	// log.Println("all resolvers failed")
	dns.HandleFailed(w, r)
}

func New(
	_listen string,
	_resolvers []string,
	_resolvconfRender bool,
) (*Dns, error) {
	var (
		_dns = &Dns{
			resolvers: parseResolvers(_resolvers),
			render:    _resolvconfRender,
			listen:    _listen,
		}
		mux = dns.NewServeMux()
	)
	if len(_dns.resolvers) == 0 {
		return nil, fmt.Errorf("not set any resolvs")
	}

	mux.HandleFunc(".", _dns.resolv)

	_dns.server = &dns.Server{
		Addr:    fmt.Sprintf("%s:53", _dns.listen),
		Net:     "udp",
		Handler: mux,
	}
	return _dns, nil
}

func (d *Dns) Run() error {
	if d.render {
		// if _, err := shell.New("systemctl", "stop", "systemd-resolved").Run(); err != nil {
		// 	log.Println(err)
		// }
		if err := d.renderConf(); err != nil {
			return fmt.Errorf("failed to /etc/resolv.conf: %w", err)
		}
	}
	if err := d.server.ListenAndServe(); err != nil {
		return fmt.Errorf("failed to start dns server: %w", err)
	}
	return nil
}

func (d *Dns) Stop() error {
	if d.render {
		if err := fs.WriteFile(respath, d.resolvconf); err != nil {
			return fmt.Errorf("resolvconf error: %w", err)
		}
		// if _, err := shell.New("systemctl", "restart", "systemd-resolved").Run(); err != nil {
		// 	log.Println(err)
		// }
	}

	if err := d.server.Shutdown(); err != nil {
		return fmt.Errorf("failed to stop dns server: %w", err)
	}
	return nil
}

func (d *Dns) renderConf() error {
	config, err := fs.ReadFile(respath)
	if err != nil {
		return fmt.Errorf("failed to read: %w", err)
	}
	d.resolvconf = config

	if err := render(respath, resolvconf, d.listen); err != nil {
		return fmt.Errorf("resolvconf error: %w", err)
	}
	return nil
}

func render(path, format, a string) error {
	if err := fs.WriteFile(path, []byte(fmt.Sprintf(format, a))); err != nil {
		return fmt.Errorf("failed to render: %w", err)
	}
	return nil
}
